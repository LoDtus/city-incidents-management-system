quá trình thực hiện docker:
- Stage 1: copy code vào app → build thành folder target
Sau khi cop thì trong app sẽ có cấu trúc như sau:
	app:
		pom.xml
		src:
			main:
				java: ...
				resources: ...

- Stage 2: copy file jar trong target và env.properties sang stage 2. Thực thi target.
	+ Với vị trí file jar trong stage 1 đang là /app/target/*.jar


Lưu ý:
- Không đẩy env.prop... lên git, đồng thời cũng không copy vào image → sẽ bị thông tin
- Nếu ai đó hoặc mình muốn chạy container thì phải tự tạo file env.prop... mới đồng cấp với Dockerfile
- Chạy container với lệnh docker run --env-file env.properties -p 8080:8080 my-image
- Dù có expose 80xx trong docker file nhưng nếu trong application.prop... mà đã định nghĩa là 80yy thì port
có thể dùng khi này chỉ có thể là 80yy, chứ 80xx vô dụng
- Nếu muốn dùng cổng khác so với cổng trong container (80yy) thì có thể sử dụng lệnh docker run với -p 80xx:80yy
80yy sẽ chuyển thành 80xx giúp người dùng có thể dùng 80xx thay vì là 80yy như đã định nghĩa trong application.prop...
- Sẽ bị lỗi với lệnh trên nếu ta có port1:port2 mà port2 lại không khớp với định nghĩa trong application.prop...
- Nếu có client hoặc microservice nào đó cũng chạy trong môi trường docker container thì bọn này sẽ cần phải giao tiếp qua 80yy,
tức là theo định nghĩa trong application.prop...
- Nếu không định nghĩa -p khi thực hiện docker run thì server vẫn chạy, nhưng chỉ chạy trong môi trường docker container. Và
cũng chỉ có những thằng chạy cùng trong môi trường này mới có thể giao tiếp tới, chứ không khai báo -p → ko có cổng ánh xạ thì
không thể tương tác với bên ngoài được
- Expose trong dockerfile chỉ mang tính chất tham khảo, thậm chí là vô dụng. Bởi nếu không khai báo server.port thì có khai báo
expose bằng giời thì spring boot vẫn sẽ chỉ chạy trên cổng mặc định của nó là 8080
